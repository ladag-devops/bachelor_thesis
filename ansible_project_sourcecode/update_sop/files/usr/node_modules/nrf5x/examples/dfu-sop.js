const api = require('nrf5x');
const path = require('path');
const serialport = require('serialport');

const DeviceInfoService = require('nrf5x/api/dfu/bleTransport/deviceInfoService');

const adapterFactory = api.AdapterFactory.getInstance(undefined, { enablePolling: false });

/**
* Application main entry.
*/
if (process.argv.length < 4) {
  help();
  process.exit(-1);
} else {
  const pathToDfuZip = process.argv[2];
  const targetAddresses = process.argv.slice(3);

  if (targetAddresses.length == 0) {
    console.error('TARGET_ADDRESS must be provided.');
    process.exit(-1);
  }

  if (pathToDfuZip == null) {
    console.error('PATH_TO_DFU_ZIP must be provided.');
    process.exit(-1);
  }

  let adapter;

  findSerialPort().then((port) => {
    return adapterFactory.createAdapter('v3', port, '');
  }).then((internal) => {
    adapter = new Adapter(internal);
    return adapter.open();
  }).then(() => {
    addAdapterListeners(adapter.internal);
    return adapter.startScan();
  }).then(() => {
    let blocked = false;
    adapter.internal.on('deviceDiscovered', (peripheral) => {
      if (blocked) { return; }
      blocked = true;

      handlePeripheral(adapter, peripheral, targetAddresses, pathToDfuZip).then(() => {
        if (targetAddresses.length === 0) {
          process.exit(0);
        }

        adapter.tryStartScan().then(() => {
          console.log('scanning...');
          blocked = false;
        }).catch((err) => {
          console.log(err);
          process.exit(-1);
        });
        
      }).catch((err) => {
        console.log(err);

        adapter.tryStartScan().then(() => {
          console.log('scanning...');
          blocked = false;
        }).catch((err) => {
          console.log(err);
          process.exit(-1);
        });
      });
    });
  }).catch((error) => {
    console.log(error);
    process.exit(-1);
  });
}

function handlePeripheral(adapter, peripheral, targetAddresses, pathToDfuZip) {
  return Promise.resolve().then(() => {
    let rssi = peripheral.rssi;
    let address = peripheral.address;
    let targetAddress = address;

    console.log(address, rssi);

    if (peripheral.name === 'DfuTarg') {
      targetAddress = changeAddress(address, -1);

      if (targetAddress.includes(targetAddress)) {
        console.log(`Starting DFU process towards ${targetAddress}`);
        console.log(pathToDfuZip);

        return performDfu(adapter.internal, address, pathToDfuZip).then(() => {
          deleteFromArray(targetAddress, targetAddresses);
          console.log('remaining', targetAddresses);
        });
      }
      return;
    }

    if (targetAddresses.includes(targetAddress)) {
      return enterDfuMode(adapter, targetAddress).then(() => {
        console.log(`Starting DFU process towards ${targetAddress}`);
        console.log(pathToDfuZip);

        address = changeAddress(targetAddress, 1);
        return performDfu(adapter.internal, address, pathToDfuZip);
      }).then(() => {
        deleteFromArray(targetAddress, targetAddresses);
        console.log('remaining', targetAddresses);
      });
    }
  });
}

function deleteFromArray(el, arr) {
  const index = arr.indexOf(el);
  if (index !== -1) {
    arr.splice(index, 1);
  }
}

function help() {
  console.log(`Usage: ${path.basename(__filename)} <PATH_TO_DFU_ZIP> <TARGET_ADDRESS> [...<TARGET_ADDRESS>]`);
  console.log();
  console.log('TARGET_ADDRESS is the BLE address of the peripheral to upgrade.');
  console.log('PATH_TO_DFU_ZIP is the zip file containing the upgrade firmware.');
  console.log();
  console.log('Example: node dfu.js ./dfu/dfu_test_app_hrm_s132.zip FF:11:22:33:AA:BF');
  console.log();
  console.log('It is assumed that the nRF device has been programmed with the correct connectivity firmware.');
}

function findSerialPort() {
  return listSerialPorts().then((ports) => {
    for (const port of ports) {
      if (port.pnpId && port.pnpId.search(/Nordic_Semiconductor_nRF52_Connectivity/) !== -1) {
        return port.comName;
      }
    }
    throw new Error('Cannot find serial port.');
  });
}

function listSerialPorts() {
  return new Promise((resolve, reject) => {
    serialport.list((err, ports) => {
      err ? reject(err) : resolve(ports);
    });
  });
}

function enterDfuMode(adapter, targetAddress) {
  const serviceUUID       = '000016231212EFDE1523785FDABCD123';
  const controlPointUUID  = '000016341212EFDE1523785FDABCD123';
  const packetUUID        = '000016351212EFDE1523785FDABCD123';

  let connectedDevice = null;

  console.log('connecting...');
  return adapter.connect(targetAddress, 'BLE_GAP_ADDR_TYPE_RANDOM_STATIC').then((device) => {
    console.log('connected');
    connectedDevice = device;
    return adapter.discover(connectedDevice, serviceUUID, controlPointUUID, packetUUID);
  }).then(() => {
    return adapter.restart();
  }).then(() => {
    return adapter.disconnect(connectedDevice);
  });
}

function changeAddress(addr, val) {
  addr = addr.replace(/:/g, '');
  addr = parseInt(addr.replace(/:/g, ''), 16) + val;
  addr = addr.toString(16).toUpperCase();
  return addr.match(/.{1,2}/g).join(':');
}

function performDfu(adapter, targetAddress, pathToZip) {
  return new Promise((resolve, reject) => {
    const transportParameters = {
      adapter,
      targetAddress,
      targetAddressType: 'BLE_GAP_ADDR_TYPE_RANDOM_STATIC',
    };
    const dfu = new api.Dfu('bleTransport', transportParameters);

    addDfuListeners(dfu);

    dfu.performDFU(pathToZip, (err) => {
      if (err) {
        reject(err);
        return;
      }

      resolve();
    });
  });
}

function addAdapterListeners(adapter) {
  adapter.on('logMessage', (severity, message) => { if (severity > 3) console.log(`${message}`); });
  adapter.on('error', error => console.log(`error: ${JSON.stringify(error)}`));
  adapter.on('deviceDisconnected', device => console.log(`Device ${device.address}/${device.addressType} disconnected.`));
  adapter.on('deviceDiscovered', device => console.log(`Discovered device ${device.address}/${device.addressType}.`));
  adapter.on('deviceConnected', device => console.log(`Device ${device.address}/${device.addressType} connected.`));
}

function addDfuListeners(dfu) {
  dfu.on('logMessage', (severity, message) => console.log(message));
  dfu.on('transferStart', fileName => console.log('transferStart:', fileName));
  dfu.on('transferComplete', fileName => console.log('transferComplete:', fileName));
  dfu.on('progressUpdate', progressUpdate => {
    let output = `progressUpdate: ${progressUpdate.stage}`;
    if (progressUpdate.percentCompleted) {
      output += `: ${progressUpdate.percentCompleted}%`;
      output += `, completed bytes: ${progressUpdate.completedBytes}, total: ${progressUpdate.totalBytes}`;
      output += `, B/s: ${progressUpdate.bytesPerSecond}, average B/s: ${progressUpdate.averageBytesPerSecond}`;
    }
    console.log(output);
  });
}

class Adapter {
  constructor(internal) {
    this.internal = internal;
  }

  open() {
    return new Promise((resolve, reject) => {
      const baudRate = process.platform === 'darwin' ? 115200 : 1000000;
      console.log(`Opening adapter with ID: ${this.internal.instanceId} and baud rate: ${baudRate}...`);

      this.internal.open({ baudRate, logLevel: 'error' }, (err) => {
        if (err) {
          reject(Error(`Error opening adapter: ${err}.`));
          return;
        }

        resolve();
      });
    });
  }

  close() {
    return new Promise((resolve, reject) => {
      this.internal.close((err) => {
        err ? reject(err) : resolve();
      });
    });
  }

  getState() {
    return new Promise((resolve, reject) => {
      this.internal.getState((err, state) => {
        err ? reject(err) : resolve(state);
      });
    });
  }

  startScan() {
    const options = {
      active: true, interval: 100, window: 100, timeout: 0,
    };
    return new Promise((resolve, reject) => {
      this.internal.startScan(options, err => {
        err ? reject(err) : resolve();
      });
    });
  }

  tryStartScan() {
    const options = {
      active: true, interval: 100, window: 100, timeout: 0,
    };
    return this.getState().then((state) => {
      if (state.scanning === false) {
        return this.internal.startScan(options);
      }
    });
  }

  stopScan() {
    return new Promise((resolve, reject) => {
      this.internal.stopScan(err => {
        err ? reject(err) : resolve();
      });
    });
  }

  connect(targetAddress, targetAddressType) {
    const options = {
      scanParams: {
        active: true,
        interval: 100,
        window: 100,
        timeout: 0,
      },
      connParams: {
        min_conn_interval: 7.5,
        max_conn_interval: 7.5,
        slave_latency: 0,
        conn_sup_timeout: 4000,
      },
    };

    const addressParams = {
      address: targetAddress,
      type: targetAddressType,
    };

    return new Promise((resolve, reject) => {
      this.internal.connect(addressParams, options, (err, device) => {
        err ? reject(err) : resolve(device);
      });
    });
  }

  discover(connectedDevice, serviceUUID, controlPointUUID, packetUUID) {
    this.deviceInfoService = new DeviceInfoService(this.internal, connectedDevice.instanceId);

    return this.findCharacteristic(serviceUUID, controlPointUUID).then((indexCharId) => {
      this.indexChar = indexCharId;
      return this.findCharacteristic(serviceUUID, packetUUID);
    }).then((valueCharId) => {
      this.valueChar = valueCharId
    });
  }

  findCharacteristic(serviceUuid, charUuid) {
    return new Promise((resolve, reject) => {
      this.deviceInfoService.getCharacteristicId(serviceUuid, charUuid).then((characteristicId) => {
        resolve(characteristicId);
      }).catch((err) => {
        if (err.code === 0x08) {
          resolve(null);
        } else {
          reject(err);
        }
      });
    });
  }

  writeCharacteristicValue(charId, data, ack) {
    return new Promise((resolve, reject) => {
      const value = Array.prototype.slice.call(data, 0);
      this.internal.writeCharacteristicValue(charId, value, ack, (err) => {
        err ? reject(err) : resolve();
      });
    });
  }

  disconnect(connectedDevice) {
    return new Promise((resolve, reject) => {
      const TIMEOUT_MS = 10 * 1000;

      const cleanup = () => {
        clearTimeout(timeout);
        this.internal.removeListener('deviceDisconnected', disconnectionHandler);
      };

      const disconnectionHandler = (device) => {
        if (device.instanceId === connectedDevice.instanceId) {
          cleanup();
          resolve();
        }
      };

      const timeout = setTimeout(() => {
        cleanup();
        reject(new Error('Timed out when waiting for target device to disconnect.'));
      }, TIMEOUT_MS);

      this.internal.on('deviceDisconnected', disconnectionHandler);
      this.internal.disconnect(connectedDevice.instanceId, (err) => {
        if (err) {
          cleanup();
          reject(err);
        }
      });
    });
  }

  restart() {
    return this.writeCommand(2001, 100, undefined);
  }

  writeCommand(index, command, data) {
    let buffer;

    if (data) {
      buffer = new Buffer(1 + data.length);
      buffer.writeUInt8(command, 0);
      data.copy(buffer, 1);
    } else {
      buffer = new Buffer(1);
      buffer.writeUInt8(command, 0);
    }

    return this.writeBuffer(index, buffer);
  }

  writeBuffer(offset, data) {
    return this.writeIndexChar(offset).then(() => {
      return this.writeValueChar(data);
    });
  }

  writeIndexChar(index) {
    const data = new Buffer(2);
    data.writeInt16LE(index, 0);
    return this.writeCharacteristicValue(this.indexChar, data, undefined);
  }

  writeValueChar(data) {
    return this.writeCharacteristicValue(this.valueChar, data, undefined);
  }
}
